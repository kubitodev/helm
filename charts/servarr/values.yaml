## Default values for Jellyfin

## @section Jellyfin parameters

## @param jellyfin.enabled Whether to enable Jellyfin.
## @param jellyfin.replicaCount The number of replicas to deploy.
## @param jellyfin.image.repository The Docker repository to pull the image from.
## @param jellyfin.image.tag The image tag to use.
## @param jellyfin.image.pullPolicy The logic of image pulling.
## @param jellyfin.enableDLNA Whether to enable DLNA which requires the pod to be attached to the host network in order to be useful - this can break things like ingress to the service https://jellyfin.org/docs/general/networking/dlna.html.
## @param jellyfin.service.type The type of service to create.
## @param jellyfin.service.port The port on which the service will run.
## @param jellyfin.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param jellyfin.service.annotations Additional annotations to add to the service.
## @param jellyfin.service.labels Additional labels to add to the service.
## @param jellyfin.service.loadBalancerIP The IP address to use for the LoadBalancer service. Only used if service.type is LoadBalancer.
## @param jellyfin.service.loadBalancerSourceRanges The source ranges to use for the LoadBalancer service. Only used if service.type is LoadBalancer.
## @param jellyfin.service.externalTrafficPolicy The external traffic policy to use for the service. Set to either Cluster or Local.
## @param jellyfin.ingress.enabled Whether to create an ingress for the service.
## @param jellyfin.ingress.labels Additional labels to add to the ingress.
## @param jellyfin.ingress.annotations Additional annotations to add to the ingress.
## @param jellyfin.ingress.path The path to use for the ingress.
## @param jellyfin.ingress.hosts The hosts to use for the ingress.
## @param jellyfin.ingress.tls The TLS configuration for the ingress.
## @param jellyfin.persistence.config.enabled Whether to enable persistence for the config.
## @param jellyfin.persistence.config.storageClass The storage class to use for the config.
## @param jellyfin.persistence.config.existingClaim The name of an existing claim to use for the config.
## @param jellyfin.persistence.config.subPath The subPath to use for the config's volume mount.
## @param jellyfin.persistence.config.accessMode The access mode to use for the config.
## @param jellyfin.persistence.config.size The size to use for the config.
## @param jellyfin.persistence.config.labels Additional labels to add to the config.
## @param jellyfin.persistence.config.annotations Additional annotations to add to the config.
## @param jellyfin.persistence.media.enabled Whether to enable persistence for the media.
## @param jellyfin.persistence.media.storageClass The storage class to use for the media.
## @param jellyfin.persistence.media.existingClaim The name of an existing claim to use for the media.
## @param jellyfin.persistence.media.subPath The subPath to use for the media's volume mount.
## @param jellyfin.persistence.media.accessMode The access mode to use for the media. Shared volume between all servarr applications, if running on different nodes, set to ReadWriteMany.
## @param jellyfin.persistence.media.size The size to use for the media.
## @param jellyfin.persistence.media.labels Additional labels to add to the media.
## @param jellyfin.persistence.media.annotations Additional annotations to add to the media.
## @param jellyfin.persistence.extraExistingClaimMounts Additional existing claim mounts to add to the pod.
## @param jellyfin.resources The resources to use for the pod.
## @param jellyfin.nodeSelector The node selector to use for the pod.
## @param jellyfin.tolerations The tolerations to use for the pod.
## @param jellyfin.affinity The affinity to use for the pod.
## @param jellyfin.extraVolumes Additional volumes to add to the pod.
## @param jellyfin.extraVolumeMounts Additional volume mounts to add to the pod.
## @param jellyfin.extraEnvVars Additional environment variables to add to the pod.
## @param jellyfin.extraInitContainers Additional init containers to add to the pod.
## @param jellyfin.extraContainers Additional sidecar containers to add to the pod.
## @param jellyfin.podSecurityContext The security context to use for the pod.
## @param jellyfin.securityContext The security context to use for the container.
## @param jellyfin.livenessProbe.enabled Whether to enable the liveness probe.
## @param jellyfin.livenessProbe.failureThreshold The number of times to retry before giving up.
## @param jellyfin.livenessProbe.initialDelaySeconds The number of seconds to wait before starting the probe.
## @param jellyfin.livenessProbe.periodSeconds The number of seconds between probe attempts.
## @param jellyfin.livenessProbe.successThreshold The minimum consecutive successes required to consider the probe successful.
## @param jellyfin.livenessProbe.timeoutSeconds The number of seconds after which the probe times out.
## @param jellyfin.readinessProbe.enabled Whether to enable the readiness probe.
## @param jellyfin.readinessProbe.failureThreshold The number of times to retry before giving up.
## @param jellyfin.readinessProbe.initialDelaySeconds The number of seconds to wait before starting the probe.
## @param jellyfin.readinessProbe.periodSeconds The number of seconds between probe attempts.
## @param jellyfin.readinessProbe.successThreshold The minimum consecutive successes required to consider the probe successful.
## @param jellyfin.readinessProbe.timeoutSeconds The number of seconds after which the probe times out.
## @param jellyfin.tailscale.enabled Whether to enable tailscale integration.
## @param jellyfin.tailscale.sidecar.enabled Whether to enable sidecar container mode. Requires the tailscale auth key.
## @param jellyfin.tailscale.sidecar.authKey The tailscale auth key to use for the sidecar container.
## @param jellyfin.tailscale.sidecar.existingAuthSecret The name of an existing secret containing the tailscale auth key as TS_AUTHKEY.
## @param jellyfin.tailscale.ingress.enabled Whether to enable ingress mode. Requires the tailscale operator to be preinstalled and is required when enableDLNA is true.
## @param jellyfin.tailscale.ingress.host The hostname of the tailscale node. Uses magicDNS, requires it to be enabled along with HTTPS on the tailscale dashboard.
##
jellyfin:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/jellyfin
    tag: "10.10.1"
    pullPolicy: IfNotPresent

  enableDLNA: false

  service:
    type: ClusterIP
    port: 8096
    nodePort: ""
    annotations: {}
    labels: {}
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    externalTrafficPolicy: null

  ingress:
    enabled: false
    labels: {}
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    path: /
    hosts:
      - chart-example.local
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  persistence:
    config:
      enabled: true
      storageClass: ""
      existingClaim: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 1Gi
      labels: {}
      annotations: {}
    media:
      enabled: true
      storageClass: ""
      existingClaim: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 10Gi
      labels: {}
      annotations: {}

    extraExistingClaimMounts: []
      # - name: external-mount
      #   mountPath: /srv/external-mount
      ## If defined, a manually managed PVC must be created before volume binding
      #   existingClaim:
      #   readOnly: true

  resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  extraVolumes: []
    #- name: renderD129
    #  hostPath:
    #    path: /dev/dri/renderD129

  extraVolumeMounts: []
    #- mountPath: /dev/dri/renderD129
    #  name: renderD129

  extraEnvVars: []
    #- name: MY_ENV_VAR
    #  value: my-env-var-value

  extraInitContainers: {}

  extraContainers: {}

  podSecurityContext: {}
  # Jellyfin can be run as an unprivileged user with the following settings:
    # runAsUser: 65534
    # runAsGroup: 65534

  securityContext: {}
  # For example, you might need to grant the following capabilities to enable hardware acceleration when mounting a /dev/dri device:
    # capabilities:
    #   add:
    #     - "SYS_ADMIN"
    #   drop:
    #     - "ALL"

  livenessProbe:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  readinessProbe:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  tailscale:
    enabled: false
    sidecar:
      enabled: true
      authKey: ""
      existingAuthSecret: ""
    ingress:
      enabled: false
      host: ""

## @section Sonarr parameters

## @param sonarr.enabled Whether to enable Sonarr.
## @param sonarr.replicaCount The number of replicas to deploy.
## @param sonarr.image.repository The Docker repository to pull the image from.
## @param sonarr.image.tag The image tag to use.
## @param sonarr.image.pullPolicy The logic of image pulling.
## @param sonarr.imagePullSecrets The image pull secrets to use.
## @param sonarr.deployment.strategy.type The deployment strategy to use.
## @param sonarr.serviceAccount.create Whether to create a service account.
## @param sonarr.serviceAccount.annotations Additional annotations to add to the service account.
## @param sonarr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param sonarr.podAnnotations Additional annotations to add to the pod.
## @param sonarr.podSecurityContext The security context to use for the pod.
## @param sonarr.securityContext The security context to use for the container.
## @param sonarr.initContainers Additional init containers to add to the pod.
## @param sonarr.service.type The type of service to create.
## @param sonarr.service.port The port on which the service will run.
## @param sonarr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param sonarr.ingress.enabled Whether to create an ingress for the service.
## @param sonarr.ingress.className The ingress class name to use.
## @param sonarr.ingress.annotations Additional annotations to add to the ingress.
## @param sonarr.ingress.hosts[0].host The host to use for the ingress.
## @param sonarr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param sonarr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param sonarr.ingress.tls The TLS configuration for the ingress.
## @param sonarr.resources The resources to use for the pod.
## @param sonarr.autoscaling.enabled Whether to enable autoscaling.
## @param sonarr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param sonarr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param sonarr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param sonarr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param sonarr.nodeSelector The node selector to use for the pod.
## @param sonarr.tolerations The tolerations to use for the pod.
## @param sonarr.affinity The affinity to use for the pod.
## @param sonarr.env.PUID The user ID to use for the pod.
## @param sonarr.env.PGID The group ID to use for the pod.
## @param sonarr.env.TZ The timezone to use for the pod.
## @param sonarr.env.UMASK The umask to use for the pod.
## @param sonarr.persistence.enabled Whether to enable persistence.
## @param sonarr.persistence.path The path to use for the persistence. Don't use slashes.
## @param sonarr.persistence.storageClass The storage class to use for the persistence.
## @param sonarr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param sonarr.persistence.accessMode The access mode to use for the persistence.
## @param sonarr.persistence.size The size to use for the persistence.
## @param sonarr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param sonarr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
sonarr:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/sonarr
    pullPolicy: IfNotPresent
    tag: "4.0.10"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # -- Init Containers
  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 80
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"
    UMASK: "002"

  persistence:
    enabled: true
    path: tv
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section qBittorrent parameters

## @param qbittorrent.enabled Whether to enable qBittorrent.
## @param qbittorrent.replicaCount The number of replicas to deploy.
## @param qbittorrent.image.repository The Docker repository to pull the image from.
## @param qbittorrent.image.tag The image tag to use.
## @param qbittorrent.image.pullPolicy The logic of image pulling.
## @param qbittorrent.imagePullSecrets The image pull secrets to use.
## @param qbittorrent.deployment.strategy.type The deployment strategy to use.
## @param qbittorrent.serviceAccount.create Whether to create a service account.
## @param qbittorrent.serviceAccount.annotations Additional annotations to add to the service account.
## @param qbittorrent.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param qbittorrent.podAnnotations Additional annotations to add to the pod.
## @param qbittorrent.podSecurityContext The security context to use for the pod.
## @param qbittorrent.securityContext The security context to use for the container.
## @param qbittorrent.initContainers Additional init containers to add to the pod.
## @param qbittorrent.service.web.type The type of service to create.
## @param qbittorrent.service.web.port The port on which the service will run.
## @param qbittorrent.service.web.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param qbittorrent.service.bt.type The type of service to create.
## @param qbittorrent.service.bt.port The port on which the service will run.
## @param qbittorrent.service.bt.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param qbittorrent.ingress.enabled Whether to create an ingress for the service.
## @param qbittorrent.ingress.className The ingress class name to use.
## @param qbittorrent.ingress.annotations Additional annotations to add to the ingress.
## @param qbittorrent.ingress.hosts[0].host The host to use for the ingress.
## @param qbittorrent.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param qbittorrent.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param qbittorrent.ingress.tls The TLS configuration for the ingress.
## @param qbittorrent.resources The resources to use for the pod.
## @param qbittorrent.autoscaling.enabled Whether to enable autoscaling.
## @param qbittorrent.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param qbittorrent.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param qbittorrent.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param qbittorrent.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param qbittorrent.nodeSelector The node selector to use for the pod.
## @param qbittorrent.tolerations The tolerations to use for the pod.
## @param qbittorrent.affinity The affinity to use for the pod.
## @param qbittorrent.env.PUID The user ID to use for the pod.
## @param qbittorrent.env.PGID The group ID to use for the pod.
## @param qbittorrent.env.TZ The timezone to use for the pod.
## @param qbittorrent.persistence.enabled Whether to enable persistence.
## @param qbittorrent.persistence.path The path to use for the persistence. Don't use slashes.
## @param qbittorrent.persistence.storageClass The storage class to use for the persistence.
## @param qbittorrent.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param qbittorrent.persistence.accessMode The access mode to use for the persistence.
## @param qbittorrent.persistence.size The size to use for the persistence.
## @param qbittorrent.persistence.additionalVolumes Additional volumes to add to the pod.
## @param qbittorrent.persistence.additionalMounts Additional volume mounts to add to the pod.
##
qbittorrent:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/qbittorrent
    pullPolicy: IfNotPresent
    tag: "4.6.7"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    web:
      type: ClusterIP
      port: 8080
      nodePort: ""
    bt:
      type: ClusterIP
      port: 6881
      nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"

  persistence:
    enabled: true
    path: downloads
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section Prowlarr parameters

## @param prowlarr.enabled Whether to enable Prowlarr.
## @param prowlarr.replicaCount The number of replicas to deploy.
## @param prowlarr.image.repository The Docker repository to pull the image from.
## @param prowlarr.image.tag The image tag to use.
## @param prowlarr.image.pullPolicy The logic of image pulling.
## @param prowlarr.imagePullSecrets The image pull secrets to use.
## @param prowlarr.deployment.strategy.type The deployment strategy to use.
## @param prowlarr.serviceAccount.create Whether to create a service account.
## @param prowlarr.serviceAccount.annotations Additional annotations to add to the service account.
## @param prowlarr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param prowlarr.podAnnotations Additional annotations to add to the pod.
## @param prowlarr.podSecurityContext The security context to use for the pod.
## @param prowlarr.securityContext The security context to use for the container.
## @param prowlarr.initContainers Additional init containers to add to the pod.
## @param prowlarr.service.type The type of service to create.
## @param prowlarr.service.port The port on which the service will run.
## @param prowlarr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param prowlarr.ingress.enabled Whether to create an ingress for the service.
## @param prowlarr.ingress.className The ingress class name to use.
## @param prowlarr.ingress.annotations Additional annotations to add to the ingress.
## @param prowlarr.ingress.hosts[0].host The host to use for the ingress.
## @param prowlarr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param prowlarr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param prowlarr.ingress.tls The TLS configuration for the ingress.
## @param prowlarr.resources The resources to use for the pod.
## @param prowlarr.autoscaling.enabled Whether to enable autoscaling.
## @param prowlarr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param prowlarr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param prowlarr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param prowlarr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param prowlarr.nodeSelector The node selector to use for the pod.
## @param prowlarr.tolerations The tolerations to use for the pod.
## @param prowlarr.affinity The affinity to use for the pod.
## @param prowlarr.env.PUID The user ID to use for the pod.
## @param prowlarr.env.PGID The group ID to use for the pod.
## @param prowlarr.env.TZ The timezone to use for the pod.
## @param prowlarr.env.UMASK The umask to use for the pod.
## @param prowlarr.persistence.enabled Whether to enable persistence.
## @param prowlarr.persistence.storageClass The storage class to use for the persistence.
## @param prowlarr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param prowlarr.persistence.accessMode The access mode to use for the persistence.
## @param prowlarr.persistence.size The size to use for the persistence.
## @param prowlarr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param prowlarr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
prowlarr:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/prowlarr
    pullPolicy: IfNotPresent
    tag: "1.25.4"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # -- Init Containers
  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 9696
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"
    UMASK: "002"

  persistence:
    enabled: true
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section FlareSolverr parameters

## @param flaresolverr.enabled Whether to enable FlareSolverr.
## @param flaresolverr.replicaCount The number of replicas to deploy.
## @param flaresolverr.image.repository The Docker repository to pull the image from.
## @param flaresolverr.image.tag The image tag to use.
## @param flaresolverr.image.pullPolicy The logic of image pulling.
## @param flaresolverr.imagePullSecrets The image pull secrets to use.
## @param flaresolverr.deployment.strategy.type The deployment strategy to use.
## @param flaresolverr.serviceAccount.create Whether to create a service account.
## @param flaresolverr.serviceAccount.annotations Additional annotations to add to the service account.
## @param flaresolverr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param flaresolverr.podAnnotations Additional annotations to add to the pod.
## @param flaresolverr.podSecurityContext.fsGroup The group ID to use for the pod.
## @param flaresolverr.podSecurityContext.fsGroupChangePolicy The policy to use for the pod.
## @param flaresolverr.securityContext.allowPrivilegeEscalation Whether to allow privilege escalation.
## @param flaresolverr.securityContext.capabilities.drop The capabilities to drop.
## @param flaresolverr.securityContext.readOnlyRootFilesystem Whether to use a read-only root filesystem.
## @param flaresolverr.securityContext.runAsNonRoot Whether to run as a non-root user.
## @param flaresolverr.securityContext.privileged Whether to run in privileged mode.
## @param flaresolverr.securityContext.runAsUser The user ID to use for the container.
## @param flaresolverr.securityContext.runAsGroup The group ID to use for the container.
## @param flaresolverr.securityContext.seccompProfile.type The type of seccomp profile to use.
## @param flaresolverr.initContainers Additional init containers to add to the pod.
## @param flaresolverr.service.type The type of service to create.
## @param flaresolverr.service.port The port on which the service will run.
## @param flaresolverr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param flaresolverr.ingress.enabled Whether to create an ingress for the service.
## @param flaresolverr.ingress.className The ingress class name to use.
## @param flaresolverr.ingress.annotations Additional annotations to add to the ingress.
## @param flaresolverr.ingress.hosts[0].host The host to use for the ingress.
## @param flaresolverr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param flaresolverr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param flaresolverr.ingress.tls The TLS configuration for the ingress.
## @param flaresolverr.resources The resources to use for the pod.
## @param flaresolverr.autoscaling.enabled Whether to enable autoscaling.
## @param flaresolverr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param flaresolverr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param flaresolverr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param flaresolverr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param flaresolverr.nodeSelector The node selector to use for the pod.
## @param flaresolverr.tolerations The tolerations to use for the pod.
## @param flaresolverr.affinity The affinity to use for the pod.
##
flaresolverr:
  enabled: true
  replicaCount: 1

  image:
    repository: ghcr.io/flaresolverr/flaresolverr
    pullPolicy: IfNotPresent
    tag: "v3.3.21"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext:
    fsGroup: 1000
    fsGroupChangePolicy: OnRootMismatch

  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    privileged: false
    runAsUser: 1000
    runAsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 8191
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

## @section Jellyseerr parameters

## @param jellyseerr.enabled Whether to enable Jellyseerr.
## @param jellyseerr.replicaCount The number of replicas to deploy.
## @param jellyseerr.image.repository The Docker repository to pull the image from.
## @param jellyseerr.image.tag The image tag to use.
## @param jellyseerr.image.pullPolicy The logic of image pulling.
## @param jellyseerr.imagePullSecrets The image pull secrets to use.
## @param jellyseerr.deployment.strategy.type The deployment strategy to use.
## @param jellyseerr.serviceAccount.create Whether to create a service account.
## @param jellyseerr.serviceAccount.annotations Additional annotations to add to the service account.
## @param jellyseerr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param jellyseerr.podAnnotations Additional annotations to add to the pod.
## @param jellyseerr.podSecurityContext The security context to use for the pod.
## @param jellyseerr.securityContext The security context to use for the container.
## @param jellyseerr.initContainers Additional init containers to add to the pod.
## @param jellyseerr.service.type The type of service to create.
## @param jellyseerr.service.port The port on which the service will run.
## @param jellyseerr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param jellyseerr.ingress.enabled Whether to create an ingress for the service.
## @param jellyseerr.ingress.className The ingress class name to use.
## @param jellyseerr.ingress.annotations Additional annotations to add to the ingress.
## @param jellyseerr.ingress.hosts[0].host The host to use for the ingress.
## @param jellyseerr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param jellyseerr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param jellyseerr.ingress.tls The TLS configuration for the ingress.
## @param jellyseerr.resources The resources to use for the pod.
## @param jellyseerr.autoscaling.enabled Whether to enable autoscaling.
## @param jellyseerr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param jellyseerr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param jellyseerr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param jellyseerr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param jellyseerr.nodeSelector The node selector to use for the pod.
## @param jellyseerr.tolerations The tolerations to use for the pod.
## @param jellyseerr.affinity The affinity to use for the pod.
## @param jellyseerr.persistence.enabled Whether to enable persistence.
## @param jellyseerr.persistence.storageClass The storage class to use for the persistence.
## @param jellyseerr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param jellyseerr.persistence.accessMode The access mode to use for the persistence.
## @param jellyseerr.persistence.size The size to use for the persistence.
## @param jellyseerr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param jellyseerr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
jellyseerr:
  enabled: true
  replicaCount: 1

  image:
    repository: docker.io/fallenbagel/jellyseerr
    pullPolicy: IfNotPresent
    tag: "2.0.1"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # -- Init Containers
  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 5055
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  persistence:
    enabled: true
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section Bazarr parameters

## @param bazarr.enabled Whether to enable Bazarr.
## @param bazarr.replicaCount The number of replicas to deploy.
## @param bazarr.image.repository The Docker repository to pull the image from.
## @param bazarr.image.tag The image tag to use.
## @param bazarr.image.pullPolicy The logic of image pulling.
## @param bazarr.imagePullSecrets The image pull secrets to use.
## @param bazarr.deployment.strategy.type The deployment strategy to use.
## @param bazarr.serviceAccount.create Whether to create a service account.
## @param bazarr.serviceAccount.annotations Additional annotations to add to the service account.
## @param bazarr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param bazarr.podAnnotations Additional annotations to add to the pod.
## @param bazarr.podSecurityContext The security context to use for the pod.
## @param bazarr.securityContext The security context to use for the container.
## @param bazarr.initContainers Additional init containers to add to the pod.
## @param bazarr.service.type The type of service to create.
## @param bazarr.service.port The port on which the service will run.
## @param bazarr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param bazarr.ingress.enabled Whether to create an ingress for the service.
## @param bazarr.ingress.className The ingress class name to use.
## @param bazarr.ingress.annotations Additional annotations to add to the ingress.
## @param bazarr.ingress.hosts[0].host The host to use for the ingress.
## @param bazarr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param bazarr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param bazarr.ingress.tls The TLS configuration for the ingress.
## @param bazarr.resources The resources to use for the pod.
## @param bazarr.autoscaling.enabled Whether to enable autoscaling.
## @param bazarr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param bazarr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param bazarr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param bazarr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param bazarr.nodeSelector The node selector to use for the pod.
## @param bazarr.tolerations The tolerations to use for the pod.
## @param bazarr.affinity The affinity to use for the pod.
## @param bazarr.env.PUID The user ID to use for the pod.
## @param bazarr.env.PGID The group ID to use for the pod.
## @param bazarr.env.TZ The timezone to use for the pod.
## @param bazarr.persistence.enabled Whether to enable persistence.
## @param bazarr.persistence.storageClass The storage class to use for the persistence.
## @param bazarr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param bazarr.persistence.accessMode The access mode to use for the persistence.
## @param bazarr.persistence.size The size to use for the persistence.
## @param bazarr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param bazarr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
bazarr:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/bazarr
    pullPolicy: IfNotPresent
    tag: "1.4.5"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 6767
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"

  persistence:
    enabled: true
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section Radarr parameters

## @param radarr.enabled Whether to enable Radarr.
## @param radarr.replicaCount The number of replicas to deploy.
## @param radarr.image.repository The Docker repository to pull the image from.
## @param radarr.image.tag The image tag to use.
## @param radarr.image.pullPolicy The logic of image pulling.
## @param radarr.imagePullSecrets The image pull secrets to use.
## @param radarr.deployment.strategy.type The deployment strategy to use.
## @param radarr.serviceAccount.create Whether to create a service account.
## @param radarr.serviceAccount.annotations Additional annotations to add to the service account.
## @param radarr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param radarr.podAnnotations Additional annotations to add to the pod.
## @param radarr.podSecurityContext The security context to use for the pod.
## @param radarr.securityContext The security context to use for the container.
## @param radarr.initContainers Additional init containers to add to the pod.
## @param radarr.service.type The type of service to create.
## @param radarr.service.port The port on which the service will run.
## @param radarr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param radarr.ingress.enabled Whether to create an ingress for the service.
## @param radarr.ingress.className The ingress class name to use.
## @param radarr.ingress.annotations Additional annotations to add to the ingress.
## @param radarr.ingress.hosts[0].host The host to use for the ingress.
## @param radarr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param radarr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param radarr.ingress.tls The TLS configuration for the ingress.
## @param radarr.resources The resources to use for the pod.
## @param radarr.autoscaling.enabled Whether to enable autoscaling.
## @param radarr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param radarr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param radarr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param radarr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param radarr.nodeSelector The node selector to use for the pod.
## @param radarr.tolerations The tolerations to use for the pod.
## @param radarr.affinity The affinity to use for the pod.
## @param radarr.env.PUID The user ID to use for the pod.
## @param radarr.env.PGID The group ID to use for the pod.
## @param radarr.env.TZ The timezone to use for the pod.
## @param radarr.env.UMASK The umask to use for the pod.
## @param radarr.persistence.enabled Whether to enable persistence.
## @param radarr.persistence.path The path to use for the persistence. Don't use slashes.
## @param radarr.persistence.storageClass The storage class to use for the persistence.
## @param radarr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param radarr.persistence.accessMode The access mode to use for the persistence.
## @param radarr.persistence.size The size to use for the persistence.
## @param radarr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param radarr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
radarr:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/radarr
    pullPolicy: IfNotPresent
    tag: "5.14.0"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 7878
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"
    UMASK: "002"

  persistence:
    enabled: true
    path: movies
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section Lidarr parameters

## @param lidarr.enabled Whether to enable Lidarr.
## @param lidarr.replicaCount The number of replicas to deploy.
## @param lidarr.image.repository The Docker repository to pull the image from.
## @param lidarr.image.tag The image tag to use.
## @param lidarr.image.pullPolicy The logic of image pulling.
## @param lidarr.imagePullSecrets The image pull secrets to use.
## @param lidarr.deployment.strategy.type The deployment strategy to use.
## @param lidarr.serviceAccount.create Whether to create a service account.
## @param lidarr.serviceAccount.annotations Additional annotations to add to the service account.
## @param lidarr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param lidarr.podAnnotations Additional annotations to add to the pod.
## @param lidarr.podSecurityContext The security context to use for the pod.
## @param lidarr.securityContext The security context to use for the container.
## @param lidarr.initContainers Additional init containers to add to the pod.
## @param lidarr.service.type The type of service to create.
## @param lidarr.service.port The port on which the service will run.
## @param lidarr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param lidarr.ingress.enabled Whether to create an ingress for the service.
## @param lidarr.ingress.className The ingress class name to use.
## @param lidarr.ingress.annotations Additional annotations to add to the ingress.
## @param lidarr.ingress.hosts[0].host The host to use for the ingress.
## @param lidarr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param lidarr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param lidarr.ingress.tls The TLS configuration for the ingress.
## @param lidarr.resources The resources to use for the pod.
## @param lidarr.autoscaling.enabled Whether to enable autoscaling.
## @param lidarr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param lidarr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param lidarr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param lidarr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param lidarr.nodeSelector The node selector to use for the pod.
## @param lidarr.tolerations The tolerations to use for the pod.
## @param lidarr.affinity The affinity to use for the pod.
## @param lidarr.env.PUID The user ID to use for the pod.
## @param lidarr.env.PGID The group ID to use for the pod.
## @param lidarr.env.TZ The timezone to use for the pod.
## @param lidarr.env.UMASK The umask to use for the pod.
## @param lidarr.persistence.enabled Whether to enable persistence.
## @param lidarr.persistence.path The path to use for the persistence. Don't use slashes.
## @param lidarr.persistence.storageClass The storage class to use for the persistence.
## @param lidarr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param lidarr.persistence.accessMode The access mode to use for the persistence.
## @param lidarr.persistence.size The size to use for the persistence.
## @param lidarr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param lidarr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
lidarr:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/lidarr
    pullPolicy: IfNotPresent
    tag: "2.7.1"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 8686
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"
    UMASK: "002"

  persistence:
    enabled: true
    path: music
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section Readarr parameters

## @param readarr.enabled Whether to enable Readarr.
## @param readarr.replicaCount The number of replicas to deploy.
## @param readarr.image.repository The Docker repository to pull the image from.
## @param readarr.image.tag The image tag to use.
## @param readarr.image.pullPolicy The logic of image pulling.
## @param readarr.imagePullSecrets The image pull secrets to use.
## @param readarr.deployment.strategy.type The deployment strategy to use.
## @param readarr.serviceAccount.create Whether to create a service account.
## @param readarr.serviceAccount.annotations Additional annotations to add to the service account.
## @param readarr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param readarr.podAnnotations Additional annotations to add to the pod.
## @param readarr.podSecurityContext The security context to use for the pod.
## @param readarr.securityContext The security context to use for the container.
## @param readarr.initContainers Additional init containers to add to the pod.
## @param readarr.service.type The type of service to create.
## @param readarr.service.port The port on which the service will run.
## @param readarr.service.nodePort The nodePort to use for the service. Only used if service.type is NodePort.
## @param readarr.ingress.enabled Whether to create an ingress for the service.
## @param readarr.ingress.className The ingress class name to use.
## @param readarr.ingress.annotations Additional annotations to add to the ingress.
## @param readarr.ingress.hosts[0].host The host to use for the ingress.
## @param readarr.ingress.hosts[0].paths[0].path The path to use for the ingress.
## @param readarr.ingress.hosts[0].paths[0].pathType The path type to use for the ingress.
## @param readarr.ingress.tls The TLS configuration for the ingress.
## @param readarr.resources The resources to use for the pod.
## @param readarr.autoscaling.enabled Whether to enable autoscaling.
## @param readarr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param readarr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param readarr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param readarr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param readarr.nodeSelector The node selector to use for the pod.
## @param readarr.tolerations The tolerations to use for the pod.
## @param readarr.affinity The affinity to use for the pod.
## @param readarr.env.PUID The user ID to use for the pod.
## @param readarr.env.PGID The group ID to use for the pod.
## @param readarr.env.TZ The timezone to use for the pod.
## @param readarr.env.UMASK The umask to use for the pod.
## @param readarr.persistence.enabled Whether to enable persistence.
## @param readarr.persistence.path The path to use for the persistence. Don't use slashes.
## @param readarr.persistence.storageClass The storage class to use for the persistence.
## @param readarr.persistence.existingClaim The name of an existing claim to use for the persistence.
## @param readarr.persistence.accessMode The access mode to use for the persistence.
## @param readarr.persistence.size The size to use for the persistence.
## @param readarr.persistence.additionalVolumes Additional volumes to add to the pod.
## @param readarr.persistence.additionalMounts Additional volume mounts to add to the pod.
##
readarr:
  enabled: true
  replicaCount: 1

  image:
    repository: lscr.io/linuxserver/readarr
    pullPolicy: IfNotPresent
    tag: "0.4.2-develop"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  initContainers:
    []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  service:
    type: ClusterIP
    port: 8787
    nodePort: ""

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  env:
    PUID: "1000"
    PGID: "1000"
    TZ: "Europe/London"
    UMASK: "002"

  persistence:
    enabled: true
    path: books
    storageClass: ""
    existingClaim: ""
    accessMode: ReadWriteOnce
    size: 800Mi
    additionalVolumes: []
    additionalMounts: []

## @section Cleanuperr parameters

## @param cleanuperr.enabled Whether to enable Cleanuperr.
## @param cleanuperr.replicaCount The number of replicas to deploy.
## @param cleanuperr.image.repository The Docker repository to pull the image from.
## @param cleanuperr.image.tag The image tag to use.
## @param cleanuperr.image.pullPolicy The logic of image pulling.
## @param cleanuperr.imagePullSecrets The image pull secrets to use.
## @param cleanuperr.deployment.strategy.type The deployment strategy to use.
## @param cleanuperr.serviceAccount.create Whether to create a service account.
## @param cleanuperr.serviceAccount.annotations Additional annotations to add to the service account.
## @param cleanuperr.serviceAccount.name The name of the service account to use. If not set and create is true, a new service account will be created with a generated name.
## @param cleanuperr.podAnnotations Additional annotations to add to the pod.
## @param cleanuperr.podSecurityContext The security context to use for the pod.
## @param cleanuperr.securityContext The security context to use for the container.
## @param cleanuperr.initContainers Additional init containers to add to the pod.
## @param cleanuperr.resources The resources to use for the pod.
## @param cleanuperr.autoscaling.enabled Whether to enable autoscaling.
## @param cleanuperr.autoscaling.minReplicas The minimum number of replicas to scale to.
## @param cleanuperr.autoscaling.maxReplicas The maximum number of replicas to scale to.
## @param cleanuperr.autoscaling.targetCPUUtilizationPercentage The target CPU utilization percentage to use for autoscaling.
## @param cleanuperr.autoscaling.targetMemoryUtilizationPercentage The target memory utilization percentage to use for autoscaling.
## @param cleanuperr.nodeSelector The node selector to use for the pod.
## @param cleanuperr.tolerations The tolerations to use for the pod.
## @param cleanuperr.affinity The affinity to use for the pod.
## @param cleanuperr.secrets.existingSecret The name of an existing Secret to use for credentials instead of creating a new one.
## @param cleanuperr.secrets.qbittorrent.username The qBittorrent username to be stored in the secret.
## @param cleanuperr.secrets.qbittorrent.password The qBittorrent password to be stored in the secret.
## @param cleanuperr.secrets.sonarr.apiKey The Sonarr API key to be stored in the secret.
## @param cleanuperr.secrets.radarr.apiKey The Radarr API key to be stored in the secret.
## @param cleanuperr.secrets.lidarr.apiKey The Lidarr API key to be stored in the secret.
## @param cleanuperr.env.TZ The timezone to use for the pod.
## @param cleanuperr.env.DRY_RUN Enable dry run mode to log actions without actually performing them.
## @param cleanuperr.env.LOGGING__LOGLEVEL The log level for the application.
## @param cleanuperr.env.LOGGING__FILE__ENABLED Whether to enable file logging.
## @param cleanuperr.env.LOGGING__FILE__PATH The path to store log files.
## @param cleanuperr.env.LOGGING__ENHANCED Whether to enable enhanced logging.
## @param cleanuperr.env.HTTP_MAX_RETRIES The maximum number of HTTP retries.
## @param cleanuperr.env.HTTP_TIMEOUT The HTTP timeout in seconds.
## @param cleanuperr.env.HTTP_VALIDATE_CERT Whether to validate HTTPS certificates.
## @param cleanuperr.env.SEARCH_ENABLED Whether to enable search functionality.
## @param cleanuperr.env.SEARCH_DELAY The delay between searches in seconds.
## @param cleanuperr.env.QUEUECLEANER__ENABLED Whether to enable queue cleaner functionality.
## @param cleanuperr.env.TRIGGERS__QUEUECLEANER The cron schedule for queue cleaner.
## @param cleanuperr.env.QUEUECLEANER__IGNORED_DOWNLOADS_PATH Path to ignored downloads list. Set to /ignored to use the default.
## @param cleanuperr.env.QUEUECLEANER__RUNSEQUENTIALLY Whether to run queue cleaner sequentially.
## @param cleanuperr.env.QUEUECLEANER__IMPORT_FAILED_MAX_STRIKES Maximum failed import strikes before action.
## @param cleanuperr.env.QUEUECLEANER__IMPORT_FAILED_IGNORE_PRIVATE Whether to ignore private trackers for failed imports.
## @param cleanuperr.env.QUEUECLEANER__IMPORT_FAILED_DELETE_PRIVATE Whether to delete private tracker torrents on failed imports.
## @param cleanuperr.env.QUEUECLEANER__IMPORT_FAILED_IGNORE_PATTERNS__0 Patterns to ignore for failed imports.
## @param cleanuperr.env.QUEUECLEANER__IMPORT_FAILED_IGNORE_PATTERNS__1 Additional patterns to ignore for failed imports.
## @param cleanuperr.env.QUEUECLEANER__STALLED_MAX_STRIKES Maximum stalled strikes before action.
## @param cleanuperr.env.QUEUECLEANER__STALLED_RESET_STRIKES_ON_PROGRESS Whether to reset strikes on progress for stalled downloads.
## @param cleanuperr.env.QUEUECLEANER__STALLED_IGNORE_PRIVATE Whether to ignore private trackers for stalled torrents.
## @param cleanuperr.env.QUEUECLEANER__STALLED_DELETE_PRIVATE Whether to delete private tracker torrents when stalled.
## @param cleanuperr.env.QUEUECLEANER__DOWNLOADING_METADATA_MAX_STRIKES Maximum strikes for downloading metadata.
## @param cleanuperr.env.QUEUECLEANER__SLOW_MAX_STRIKES Maximum slow download strikes before action.
## @param cleanuperr.env.QUEUECLEANER__SLOW_RESET_STRIKES_ON_PROGRESS Whether to reset strikes on progress for slow downloads.
## @param cleanuperr.env.QUEUECLEANER__SLOW_IGNORE_PRIVATE Whether to ignore private trackers for slow downloads.
## @param cleanuperr.env.QUEUECLEANER__SLOW_DELETE_PRIVATE Whether to delete private tracker torrents when slow.
## @param cleanuperr.env.QUEUECLEANER__SLOW_MIN_SPEED Minimum speed threshold for slow downloads.
## @param cleanuperr.env.QUEUECLEANER__SLOW_MAX_TIME Maximum time allowed for slow downloads.
## @param cleanuperr.env.QUEUECLEANER__SLOW_IGNORE_ABOVE_SIZE Ignore torrents above this size for slow download checks.
## @param cleanuperr.env.CONTENTBLOCKER__ENABLED Whether to enable content blocker functionality.
## @param cleanuperr.env.TRIGGERS__CONTENTBLOCKER Cron schedule for content blocker.
## @param cleanuperr.env.CONTENTBLOCKER__IGNORED_DOWNLOADS_PATH Path to ignored downloads for content blocker. Set to /ignored to use the default.
## @param cleanuperr.env.CONTENTBLOCKER__IGNORE_PRIVATE Whether to ignore private trackers for content blocking.
## @param cleanuperr.env.CONTENTBLOCKER__DELETE_PRIVATE Whether to delete private tracker torrents when blocked.
## @param cleanuperr.env.DOWNLOADCLEANER__ENABLED Whether to enable download cleaner functionality.
## @param cleanuperr.env.TRIGGERS__DOWNLOADCLEANER Cron schedule for download cleaner.
## @param cleanuperr.env.DOWNLOADCLEANER__IGNORED_DOWNLOADS_PATH Path to ignored downloads for download cleaner. Set to /ignored to use the default.
## @param cleanuperr.env.DOWNLOADCLEANER__DELETE_PRIVATE Whether to delete private tracker torrents when cleaning.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__0__NAME Name for the first category (Sonarr).
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__1__NAME Name for the second category (Radarr).
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__2__NAME Name for the third category (Lidarr).
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__0__MAX_RATIO Max ratio for the first category.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__1__MAX_RATIO Max ratio for the second category.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__2__MAX_RATIO Max ratio for the third category.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__0__MIN_SEED_TIME Min seed time for the first category in minutes.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__1__MIN_SEED_TIME Min seed time for the second category in minutes.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__2__MIN_SEED_TIME Min seed time for the third category in minutes.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__0__MAX_SEED_TIME Max seed time for the first category in minutes.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__1__MAX_SEED_TIME Max seed time for the second category in minutes.
## @param cleanuperr.env.DOWNLOADCLEANER__CATEGORIES__2__MAX_SEED_TIME Max seed time for the third category in minutes.
## @param cleanuperr.env.DOWNLOADCLEANER__UNLINKED_TARGET_CATEGORY Target category for unlinked downloads.
## @param cleanuperr.env.DOWNLOADCLEANER__UNLINKED_USE_TAG Whether to use a tag for unlinked downloads.
## @param cleanuperr.env.DOWNLOADCLEANER__UNLINKED_IGNORED_ROOT_DIR Root directory to ignore for unlinked downloads.
## @param cleanuperr.env.DOWNLOADCLEANER__UNLINKED_CATEGORIES__0 First category to check for unlinked downloads.
## @param cleanuperr.env.DOWNLOADCLEANER__UNLINKED_CATEGORIES__1 Second category to check for unlinked downloads.
## @param cleanuperr.env.DOWNLOADCLEANER__UNLINKED_CATEGORIES__2 Third category to check for unlinked downloads.
## @param cleanuperr.env.DOWNLOAD_CLIENT The download client to use.
## @param cleanuperr.env.QBITTORRENT__URL The URL for qBittorrent web interface.
## @param cleanuperr.env.QBITTORRENT__URL_BASE The base URL for qBittorrent.
## @param cleanuperr.env.SONARR__ENABLED Whether to enable Sonarr integration.
## @param cleanuperr.env.SONARR__IMPORT_FAILED_MAX_STRIKES Maximum failed import strikes for Sonarr.
## @param cleanuperr.env.SONARR__BLOCK__TYPE The block type for Sonarr.
## @param cleanuperr.env.SONARR__BLOCK__PATH Path to the Sonarr blocklist.
## @param cleanuperr.env.SONARR__SEARCHTYPE The search type for Sonarr.
## @param cleanuperr.env.SONARR__INSTANCES__0__URL The URL for Sonarr.
## @param cleanuperr.env.RADARR__ENABLED Whether to enable Radarr integration.
## @param cleanuperr.env.RADARR__IMPORT_FAILED_MAX_STRIKES Maximum failed import strikes for Radarr.
## @param cleanuperr.env.RADARR__BLOCK__TYPE The block type for Radarr.
## @param cleanuperr.env.RADARR__BLOCK__PATH Path to the Radarr blocklist.
## @param cleanuperr.env.RADARR__INSTANCES__0__URL The URL for Radarr.
## @param cleanuperr.env.LIDARR__ENABLED Whether to enable Lidarr integration.
## @param cleanuperr.env.LIDARR__IMPORT_FAILED_MAX_STRIKES Maximum failed import strikes for Lidarr.
## @param cleanuperr.env.LIDARR__BLOCK__TYPE The block type for Lidarr.
## @param cleanuperr.env.LIDARR__BLOCK__PATH Path to the Lidarr blocklist.
## @param cleanuperr.env.LIDARR__INSTANCES__0__URL The URL for Lidarr.
## @param cleanuperr.ignoredDownloads.entries List of torrent names or patterns to ignore in the ignored_downloads.txt ConfigMap.
## @param cleanuperr.persistence.logs.enabled Whether to enable persistence.
## @param cleanuperr.persistence.logs.storageClass The storage class to use for the persistence.
## @param cleanuperr.persistence.logs.existingClaim The name of an existing claim to use for the persistence.
## @param cleanuperr.persistence.logs.accessMode The access mode to use for the persistence.
## @param cleanuperr.persistence.logs.size The size to use for the persistence.
## @param cleanuperr.persistence.logs.additionalVolumes Additional volumes to add to the pod.
## @param cleanuperr.persistence.logs.additionalMounts Additional volume mounts to add to the pod.
##
cleanuperr:
  enabled: false
  replicaCount: 1

  image:
    repository: ghcr.io/flmorg/cleanuperr
    pullPolicy: IfNotPresent
    tag: "latest"

  imagePullSecrets: []

  deployment:
    strategy:
      type: Recreate

  serviceAccount:
    create: true
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  initContainers: []
    # - name: init-container
    #   image: busybox
    #   command: ['sh', '-c', 'echo "this is an init container"']

  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  secrets:
    existingSecret: ""
    qbittorrent:
      username: ""
      password: ""
    sonarr:
      apiKey: ""
    radarr:
      apiKey: ""
    lidarr:
      apiKey: ""

  env:
    # General Settings
    TZ: "Europe/London"
    DRY_RUN: false
    LOGGING__LOGLEVEL: "Information"
    LOGGING__FILE__ENABLED: true
    LOGGING__FILE__PATH: "/var/logs"
    LOGGING__ENHANCED: true
    HTTP_MAX_RETRIES: "3"
    HTTP_TIMEOUT: "100"
    HTTP_VALIDATE_CERT: "Enabled"
    # Search Settings
    SEARCH_ENABLED: true
    SEARCH_DELAY: "30"
    # Queuecleaner Settings
    QUEUECLEANER__ENABLED: true
    TRIGGERS__QUEUECLEANER: "0 0/5 * * * ?"
    QUEUECLEANER__IGNORED_DOWNLOADS_PATH: "/ignored/ignored_downloads"
    QUEUECLEANER__RUNSEQUENTIALLY: true
    QUEUECLEANER__IMPORT_FAILED_MAX_STRIKES: "0"
    QUEUECLEANER__IMPORT_FAILED_IGNORE_PRIVATE: false
    QUEUECLEANER__IMPORT_FAILED_DELETE_PRIVATE: false
    QUEUECLEANER__IMPORT_FAILED_IGNORE_PATTERNS__0: "title mismatch"
    QUEUECLEANER__IMPORT_FAILED_IGNORE_PATTERNS__1: "manual import required"
    QUEUECLEANER__STALLED_MAX_STRIKES: "0"
    QUEUECLEANER__STALLED_RESET_STRIKES_ON_PROGRESS: "false"
    QUEUECLEANER__STALLED_IGNORE_PRIVATE: "false"
    QUEUECLEANER__STALLED_DELETE_PRIVATE: "false"
    QUEUECLEANER__DOWNLOADING_METADATA_MAX_STRIKES: "0"
    QUEUECLEANER__SLOW_MAX_STRIKES: "0"
    QUEUECLEANER__SLOW_RESET_STRIKES_ON_PROGRESS: false
    QUEUECLEANER__SLOW_IGNORE_PRIVATE: false
    QUEUECLEANER__SLOW_DELETE_PRIVATE: false
    QUEUECLEANER__SLOW_MIN_SPEED: ""
    QUEUECLEANER__SLOW_MAX_TIME: "0"
    QUEUECLEANER__SLOW_IGNORE_ABOVE_SIZE: ""
    # Content Blocker Settings
    CONTENTBLOCKER__ENABLED: true
    TRIGGERS__CONTENTBLOCKER: "0 0/5 * * * ?"
    CONTENTBLOCKER__IGNORED_DOWNLOADS_PATH: "/ignored/ignored_downloads"
    CONTENTBLOCKER__IGNORE_PRIVATE: false
    CONTENTBLOCKER__DELETE_PRIVATE: false
    # Download Cleaner Settings
    DOWNLOADCLEANER__ENABLED: true
    TRIGGERS__DOWNLOADCLEANER: "0 0 * * * ?"
    DOWNLOADCLEANER__IGNORED_DOWNLOADS_PATH: "/ignored/ignored_downloads"
    DOWNLOADCLEANER__DELETE_PRIVATE: false
    DOWNLOADCLEANER__CATEGORIES__0__NAME: "tv-sonarr"
    DOWNLOADCLEANER__CATEGORIES__1__NAME: "movies-radarr"
    DOWNLOADCLEANER__CATEGORIES__2__NAME: "music-lidarr"
    DOWNLOADCLEANER__CATEGORIES__0__MAX_RATIO: "1.0"
    DOWNLOADCLEANER__CATEGORIES__1__MAX_RATIO: "1.0"
    DOWNLOADCLEANER__CATEGORIES__2__MAX_RATIO: "1.0"
    DOWNLOADCLEANER__CATEGORIES__0__MIN_SEED_TIME: "360"
    DOWNLOADCLEANER__CATEGORIES__1__MIN_SEED_TIME: "360"
    DOWNLOADCLEANER__CATEGORIES__2__MIN_SEED_TIME: "360"
    DOWNLOADCLEANER__CATEGORIES__0__MAX_SEED_TIME: "720"
    DOWNLOADCLEANER__CATEGORIES__1__MAX_SEED_TIME: "720"
    DOWNLOADCLEANER__CATEGORIES__2__MAX_SEED_TIME: "720"
    DOWNLOADCLEANER__UNLINKED_TARGET_CATEGORY: "cleanuperr-unlinked"
    DOWNLOADCLEANER__UNLINKED_USE_TAG: false
    DOWNLOADCLEANER__UNLINKED_IGNORED_ROOT_DIR: "/media/downloads"
    DOWNLOADCLEANER__UNLINKED_CATEGORIES__0: "tv-sonarr"
    DOWNLOADCLEANER__UNLINKED_CATEGORIES__1: "movies-radarr"
    DOWNLOADCLEANER__UNLINKED_CATEGORIES__2: "music-lidarr"
    # Download Client Settings
    DOWNLOAD_CLIENT: "qbittorrent"
    QBITTORRENT__URL: "http://servarr-qbittorrent-web:8080"
    QBITTORRENT__URL_BASE: ""
    # Arrs Settings
    SONARR__ENABLED: true
    SONARR__IMPORT_FAILED_MAX_STRIKES: "-1"
    SONARR__BLOCK__TYPE: "blacklist"
    SONARR__BLOCK__PATH: "https://raw.githubusercontent.com/flmorg/cleanuperr/refs/heads/main/blacklist_permissive"
    SONARR__SEARCHTYPE: "Episode"
    SONARR__INSTANCES__0__URL: "http://servarr-sonarr:80"
    RADARR__ENABLED: true
    RADARR__IMPORT_FAILED_MAX_STRIKES: "-1"
    RADARR__BLOCK__TYPE: "blacklist"
    RADARR__BLOCK__PATH: "https://raw.githubusercontent.com/flmorg/cleanuperr/refs/heads/main/blacklist_permissive"
    RADARR__INSTANCES__0__URL: "http://servarr-radarr:7878"
    LIDARR__ENABLED: false
    LIDARR__IMPORT_FAILED_MAX_STRIKES: "-1"
    LIDARR__BLOCK__TYPE: "blacklist"
    LIDARR__BLOCK__PATH: "https://raw.githubusercontent.com/flmorg/cleanuperr/refs/heads/main/blacklist_permissive"
    LIDARR__INSTANCES__0__URL: "http://servarr-lidarr:8686"

  ignoredDownloads:
    # List of entries to add to the ignored_downloads.txt file
    # Each entry should be a torrent name or pattern to ignore
    entries: []
    # - "example.torrent"
    # - "pattern*to*ignore"

  persistence:
    logs:
      enabled: false
      storageClass: ""
      existingClaim: ""
      accessMode: ReadWriteOnce
      size: 100Mi
      additionalVolumes: []
      additionalMounts: []
